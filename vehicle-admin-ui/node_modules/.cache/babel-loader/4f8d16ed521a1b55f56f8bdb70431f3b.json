{"remainingRequest":"/Users/TaoBangren/gitee/finhub-vehicle/vehicle-admin-ui/node_modules/babel-loader/lib/index.js!/Users/TaoBangren/gitee/finhub-vehicle/vehicle-admin-ui/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/TaoBangren/gitee/finhub-vehicle/vehicle-admin-ui/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/TaoBangren/gitee/finhub-vehicle/vehicle-admin-ui/src/components/split-pane/split.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/TaoBangren/gitee/finhub-vehicle/vehicle-admin-ui/src/components/split-pane/split.vue","mtime":1734063882373},{"path":"/Users/TaoBangren/gitee/finhub-vehicle/vehicle-admin-ui/.babelrc","mtime":1734230871032},{"path":"/Users/TaoBangren/gitee/finhub-vehicle/vehicle-admin-ui/node_modules/cache-loader/dist/cjs.js","mtime":1734234711738},{"path":"/Users/TaoBangren/gitee/finhub-vehicle/vehicle-admin-ui/node_modules/babel-loader/lib/index.js","mtime":1734234712752},{"path":"/Users/TaoBangren/gitee/finhub-vehicle/vehicle-admin-ui/node_modules/cache-loader/dist/cjs.js","mtime":1734234711738},{"path":"/Users/TaoBangren/gitee/finhub-vehicle/vehicle-admin-ui/node_modules/vue-loader/lib/index.js","mtime":1734234711707}],"contextDependencies":[],"result":["import \"core-js/modules/es6.number.constructor\";\nimport { oneOf, on, off } from '@/libs/tools';\nimport Trigger from \"./trigger.vue\";\nexport default {\n  name: 'SplitPane',\n  components: {\n    Trigger: Trigger\n  },\n  props: {\n    value: {\n      type: [Number, String],\n      default: 0.5\n    },\n    mode: {\n      validator: function validator(value) {\n        return oneOf(value, ['horizontal', 'vertical']);\n      },\n      default: 'horizontal'\n    },\n    min: {\n      type: [Number, String],\n      default: '40px'\n    },\n    max: {\n      type: [Number, String],\n      default: '40px'\n    }\n  },\n  /**\n   * Events\n   * @on-move-start\n   * @on-moving 返回值：事件对象，但是在事件对象中加入了两个参数：atMin(当前是否在最小值处), atMax(当前是否在最大值处)\n   * @on-move-end\n   */\n  data: function data() {\n    return {\n      prefix: 'ivu-split',\n      offset: 0,\n      oldOffset: 0,\n      isMoving: false\n    };\n  },\n  computed: {\n    wrapperClasses: function wrapperClasses() {\n      return [\"\".concat(this.prefix, \"-wrapper\"), this.isMoving ? 'no-select' : ''];\n    },\n    isHorizontal: function isHorizontal() {\n      return this.mode === 'horizontal';\n    },\n    anotherOffset: function anotherOffset() {\n      return 100 - this.offset;\n    },\n    valueIsPx: function valueIsPx() {\n      return typeof this.value === 'string';\n    },\n    offsetSize: function offsetSize() {\n      return this.isHorizontal ? 'offsetWidth' : 'offsetHeight';\n    },\n    computedMin: function computedMin() {\n      return this.getComputedThresholdValue('min');\n    },\n    computedMax: function computedMax() {\n      return this.getComputedThresholdValue('max');\n    }\n  },\n  methods: {\n    px2percent: function px2percent(numerator, denominator) {\n      return parseFloat(numerator) / parseFloat(denominator);\n    },\n    getComputedThresholdValue: function getComputedThresholdValue(type) {\n      var size = this.$refs.outerWrapper[this.offsetSize];\n      if (this.valueIsPx) return typeof this[type] === 'string' ? this[type] : size * this[type];else return typeof this[type] === 'string' ? this.px2percent(this[type], size) : this[type];\n    },\n    getMin: function getMin(value1, value2) {\n      if (this.valueIsPx) return \"\".concat(Math.min(parseFloat(value1), parseFloat(value2)), \"px\");else return Math.min(value1, value2);\n    },\n    getMax: function getMax(value1, value2) {\n      if (this.valueIsPx) return \"\".concat(Math.max(parseFloat(value1), parseFloat(value2)), \"px\");else return Math.max(value1, value2);\n    },\n    getAnotherOffset: function getAnotherOffset(value) {\n      var res = 0;\n      if (this.valueIsPx) res = \"\".concat(this.$refs.outerWrapper[this.offsetSize] - parseFloat(value), \"px\");else res = 1 - value;\n      return res;\n    },\n    handleMove: function handleMove(e) {\n      var pageOffset = this.isHorizontal ? e.pageX : e.pageY;\n      var offset = pageOffset - this.initOffset;\n      var outerWidth = this.$refs.outerWrapper[this.offsetSize];\n      var value = this.valueIsPx ? \"\".concat(parseFloat(this.oldOffset) + offset, \"px\") : this.px2percent(outerWidth * this.oldOffset + offset, outerWidth);\n      var anotherValue = this.getAnotherOffset(value);\n      if (parseFloat(value) <= parseFloat(this.computedMin)) value = this.getMax(value, this.computedMin);\n      if (parseFloat(anotherValue) <= parseFloat(this.computedMax)) value = this.getAnotherOffset(this.getMax(anotherValue, this.computedMax));\n      e.atMin = this.value === this.computedMin;\n      e.atMax = this.valueIsPx ? this.getAnotherOffset(this.value) === this.computedMax : this.getAnotherOffset(this.value).toFixed(5) === this.computedMax.toFixed(5);\n      this.$emit('input', value);\n      this.$emit('on-moving', e);\n    },\n    handleUp: function handleUp() {\n      this.isMoving = false;\n      off(document, 'mousemove', this.handleMove);\n      off(document, 'mouseup', this.handleUp);\n      this.$emit('on-move-end');\n    },\n    handleMousedown: function handleMousedown(e) {\n      this.initOffset = this.isHorizontal ? e.pageX : e.pageY;\n      this.oldOffset = this.value;\n      this.isMoving = true;\n      on(document, 'mousemove', this.handleMove);\n      on(document, 'mouseup', this.handleUp);\n      this.$emit('on-move-start');\n    }\n  },\n  watch: {\n    value: function value() {\n      this.offset = (this.valueIsPx ? this.px2percent(this.value, this.$refs.outerWrapper[this.offsetSize]) : this.value) * 10000 / 100;\n    }\n  },\n  mounted: function mounted() {\n    var _this = this;\n    this.$nextTick(function () {\n      _this.offset = (_this.valueIsPx ? _this.px2percent(_this.value, _this.$refs.outerWrapper[_this.offsetSize]) : _this.value) * 10000 / 100;\n    });\n  }\n};",{"version":3,"names":["oneOf","on","off","Trigger","name","components","props","value","type","Number","String","default","mode","validator","min","max","data","prefix","offset","oldOffset","isMoving","computed","wrapperClasses","concat","isHorizontal","anotherOffset","valueIsPx","offsetSize","computedMin","getComputedThresholdValue","computedMax","methods","px2percent","numerator","denominator","parseFloat","size","$refs","outerWrapper","getMin","value1","value2","Math","getMax","getAnotherOffset","res","handleMove","e","pageOffset","pageX","pageY","initOffset","outerWidth","anotherValue","atMin","atMax","toFixed","$emit","handleUp","document","handleMousedown","watch","mounted","_this","$nextTick"],"sources":["src/components/split-pane/split.vue"],"sourcesContent":["<template>\n  <div ref=\"outerWrapper\" :class=\"wrapperClasses\">\n    <div v-if=\"isHorizontal\" :class=\"`${prefix}-horizontal`\">\n      <div :style=\"{right: `${anotherOffset}%`}\" :class=\"[`${prefix}-pane`, 'left-pane']\">\n        <slot name=\"left\"/>\n      </div>\n      <div :class=\"`${prefix}-trigger-con`\" :style=\"{left: `${offset}%`}\" @mousedown=\"handleMousedown\">\n        <slot name=\"trigger\">\n          <trigger mode=\"vertical\"/>\n        </slot>\n      </div>\n      <div :style=\"{left: `${offset}%`}\" :class=\"[`${prefix}-pane`, 'right-pane']\">\n        <slot name=\"right\"/>\n      </div>\n    </div>\n    <div v-else :class=\"`${prefix}-vertical`\">\n      <div :style=\"{bottom: `${anotherOffset}%`}\" :class=\"[`${prefix}-pane`, 'top-pane']\">\n        <slot name=\"top\"/>\n      </div>\n      <div :class=\"`${prefix}-trigger-con`\" :style=\"{top: `${offset}%`}\" @mousedown=\"handleMousedown\">\n        <slot name=\"trigger\">\n          <trigger mode=\"horizontal\"/>\n        </slot>\n      </div>\n      <div :style=\"{top: `${offset}%`}\" :class=\"[`${prefix}-pane`, 'bottom-pane']\">\n        <slot name=\"bottom\"/>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\n  import { oneOf, on, off } from '@/libs/tools'\n  import Trigger from './trigger.vue'\n\n  export default {\n    name: 'SplitPane',\n    components: {\n      Trigger\n    },\n    props: {\n      value: {\n        type: [Number, String],\n        default: 0.5\n      },\n      mode: {\n        validator (value) {\n          return oneOf(value, ['horizontal', 'vertical'])\n        },\n        default: 'horizontal'\n      },\n      min: {\n        type: [Number, String],\n        default: '40px'\n      },\n      max: {\n        type: [Number, String],\n        default: '40px'\n      }\n    },\n    /**\n     * Events\n     * @on-move-start\n     * @on-moving 返回值：事件对象，但是在事件对象中加入了两个参数：atMin(当前是否在最小值处), atMax(当前是否在最大值处)\n     * @on-move-end\n     */\n    data () {\n      return {\n        prefix: 'ivu-split',\n        offset: 0,\n        oldOffset: 0,\n        isMoving: false\n      }\n    },\n    computed: {\n      wrapperClasses () {\n        return [\n          `${this.prefix}-wrapper`,\n          this.isMoving ? 'no-select' : ''\n        ]\n      },\n      isHorizontal () {\n        return this.mode === 'horizontal'\n      },\n      anotherOffset () {\n        return 100 - this.offset\n      },\n      valueIsPx () {\n        return typeof this.value === 'string'\n      },\n      offsetSize () {\n        return this.isHorizontal ? 'offsetWidth' : 'offsetHeight'\n      },\n      computedMin () {\n        return this.getComputedThresholdValue('min')\n      },\n      computedMax () {\n        return this.getComputedThresholdValue('max')\n      }\n    },\n    methods: {\n      px2percent (numerator, denominator) {\n        return parseFloat(numerator) / parseFloat(denominator)\n      },\n      getComputedThresholdValue (type) {\n        let size = this.$refs.outerWrapper[this.offsetSize]\n        if (this.valueIsPx) return typeof this[type] === 'string' ? this[type] : size * this[type]\n        else return typeof this[type] === 'string' ? this.px2percent(this[type], size) : this[type]\n      },\n      getMin (value1, value2) {\n        if (this.valueIsPx) return `${Math.min(parseFloat(value1), parseFloat(value2))}px`\n        else return Math.min(value1, value2)\n      },\n      getMax (value1, value2) {\n        if (this.valueIsPx) return `${Math.max(parseFloat(value1), parseFloat(value2))}px`\n        else return Math.max(value1, value2)\n      },\n      getAnotherOffset (value) {\n        let res = 0\n        if (this.valueIsPx) res = `${this.$refs.outerWrapper[this.offsetSize] - parseFloat(value)}px`\n        else res = 1 - value\n        return res\n      },\n      handleMove (e) {\n        let pageOffset = this.isHorizontal ? e.pageX : e.pageY\n        let offset = pageOffset - this.initOffset\n        let outerWidth = this.$refs.outerWrapper[this.offsetSize]\n        let value = this.valueIsPx ? `${parseFloat(this.oldOffset) + offset}px` : (this.px2percent(outerWidth * this.oldOffset + offset, outerWidth))\n        let anotherValue = this.getAnotherOffset(value)\n        if (parseFloat(value) <= parseFloat(this.computedMin)) value = this.getMax(value, this.computedMin)\n        if (parseFloat(anotherValue) <= parseFloat(this.computedMax)) value = this.getAnotherOffset(this.getMax(anotherValue, this.computedMax))\n        e.atMin = this.value === this.computedMin\n        e.atMax = this.valueIsPx ? this.getAnotherOffset(this.value) === this.computedMax : this.getAnotherOffset(this.value).toFixed(5) === this.computedMax.toFixed(5)\n        this.$emit('input', value)\n        this.$emit('on-moving', e)\n      },\n      handleUp () {\n        this.isMoving = false\n        off(document, 'mousemove', this.handleMove)\n        off(document, 'mouseup', this.handleUp)\n        this.$emit('on-move-end')\n      },\n      handleMousedown (e) {\n        this.initOffset = this.isHorizontal ? e.pageX : e.pageY\n        this.oldOffset = this.value\n        this.isMoving = true\n        on(document, 'mousemove', this.handleMove)\n        on(document, 'mouseup', this.handleUp)\n        this.$emit('on-move-start')\n      }\n    },\n    watch: {\n      value () {\n        this.offset = (this.valueIsPx ? this.px2percent(this.value, this.$refs.outerWrapper[this.offsetSize]) : this.value) * 10000 / 100\n      }\n    },\n    mounted () {\n      this.$nextTick(() => {\n        this.offset = (this.valueIsPx ? this.px2percent(this.value, this.$refs.outerWrapper[this.offsetSize]) : this.value) * 10000 / 100\n      })\n    }\n  }\n</script>\n\n<style lang=\"less\">\n  @import './index.less';\n</style>\n"],"mappings":";AAgCA,SAAAA,KAAA,EAAAC,EAAA,EAAAC,GAAA;AACA,OAAAC,OAAA;AAEA;EACAC,IAAA;EACAC,UAAA;IACAF,OAAA,EAAAA;EACA;EACAG,KAAA;IACAC,KAAA;MACAC,IAAA,GAAAC,MAAA,EAAAC,MAAA;MACAC,OAAA;IACA;IACAC,IAAA;MACAC,SAAA,WAAAA,UAAAN,KAAA;QACA,OAAAP,KAAA,CAAAO,KAAA;MACA;MACAI,OAAA;IACA;IACAG,GAAA;MACAN,IAAA,GAAAC,MAAA,EAAAC,MAAA;MACAC,OAAA;IACA;IACAI,GAAA;MACAP,IAAA,GAAAC,MAAA,EAAAC,MAAA;MACAC,OAAA;IACA;EACA;EACA;AACA;AACA;AACA;AACA;AACA;EACAK,IAAA,WAAAA,KAAA;IACA;MACAC,MAAA;MACAC,MAAA;MACAC,SAAA;MACAC,QAAA;IACA;EACA;EACAC,QAAA;IACAC,cAAA,WAAAA,eAAA;MACA,WAAAC,MAAA,CACA,KAAAN,MAAA,eACA,KAAAG,QAAA,oBACA;IACA;IACAI,YAAA,WAAAA,aAAA;MACA,YAAAZ,IAAA;IACA;IACAa,aAAA,WAAAA,cAAA;MACA,kBAAAP,MAAA;IACA;IACAQ,SAAA,WAAAA,UAAA;MACA,mBAAAnB,KAAA;IACA;IACAoB,UAAA,WAAAA,WAAA;MACA,YAAAH,YAAA;IACA;IACAI,WAAA,WAAAA,YAAA;MACA,YAAAC,yBAAA;IACA;IACAC,WAAA,WAAAA,YAAA;MACA,YAAAD,yBAAA;IACA;EACA;EACAE,OAAA;IACAC,UAAA,WAAAA,WAAAC,SAAA,EAAAC,WAAA;MACA,OAAAC,UAAA,CAAAF,SAAA,IAAAE,UAAA,CAAAD,WAAA;IACA;IACAL,yBAAA,WAAAA,0BAAArB,IAAA;MACA,IAAA4B,IAAA,QAAAC,KAAA,CAAAC,YAAA,MAAAX,UAAA;MACA,SAAAD,SAAA,qBAAAlB,IAAA,sBAAAA,IAAA,IAAA4B,IAAA,QAAA5B,IAAA,OACA,mBAAAA,IAAA,sBAAAwB,UAAA,MAAAxB,IAAA,GAAA4B,IAAA,SAAA5B,IAAA;IACA;IACA+B,MAAA,WAAAA,OAAAC,MAAA,EAAAC,MAAA;MACA,SAAAf,SAAA,YAAAH,MAAA,CAAAmB,IAAA,CAAA5B,GAAA,CAAAqB,UAAA,CAAAK,MAAA,GAAAL,UAAA,CAAAM,MAAA,eACA,OAAAC,IAAA,CAAA5B,GAAA,CAAA0B,MAAA,EAAAC,MAAA;IACA;IACAE,MAAA,WAAAA,OAAAH,MAAA,EAAAC,MAAA;MACA,SAAAf,SAAA,YAAAH,MAAA,CAAAmB,IAAA,CAAA3B,GAAA,CAAAoB,UAAA,CAAAK,MAAA,GAAAL,UAAA,CAAAM,MAAA,eACA,OAAAC,IAAA,CAAA3B,GAAA,CAAAyB,MAAA,EAAAC,MAAA;IACA;IACAG,gBAAA,WAAAA,iBAAArC,KAAA;MACA,IAAAsC,GAAA;MACA,SAAAnB,SAAA,EAAAmB,GAAA,MAAAtB,MAAA,MAAAc,KAAA,CAAAC,YAAA,MAAAX,UAAA,IAAAQ,UAAA,CAAA5B,KAAA,cACAsC,GAAA,OAAAtC,KAAA;MACA,OAAAsC,GAAA;IACA;IACAC,UAAA,WAAAA,WAAAC,CAAA;MACA,IAAAC,UAAA,QAAAxB,YAAA,GAAAuB,CAAA,CAAAE,KAAA,GAAAF,CAAA,CAAAG,KAAA;MACA,IAAAhC,MAAA,GAAA8B,UAAA,QAAAG,UAAA;MACA,IAAAC,UAAA,QAAAf,KAAA,CAAAC,YAAA,MAAAX,UAAA;MACA,IAAApB,KAAA,QAAAmB,SAAA,MAAAH,MAAA,CAAAY,UAAA,MAAAhB,SAAA,IAAAD,MAAA,eAAAc,UAAA,CAAAoB,UAAA,QAAAjC,SAAA,GAAAD,MAAA,EAAAkC,UAAA;MACA,IAAAC,YAAA,QAAAT,gBAAA,CAAArC,KAAA;MACA,IAAA4B,UAAA,CAAA5B,KAAA,KAAA4B,UAAA,MAAAP,WAAA,GAAArB,KAAA,QAAAoC,MAAA,CAAApC,KAAA,OAAAqB,WAAA;MACA,IAAAO,UAAA,CAAAkB,YAAA,KAAAlB,UAAA,MAAAL,WAAA,GAAAvB,KAAA,QAAAqC,gBAAA,MAAAD,MAAA,CAAAU,YAAA,OAAAvB,WAAA;MACAiB,CAAA,CAAAO,KAAA,QAAA/C,KAAA,UAAAqB,WAAA;MACAmB,CAAA,CAAAQ,KAAA,QAAA7B,SAAA,QAAAkB,gBAAA,MAAArC,KAAA,WAAAuB,WAAA,QAAAc,gBAAA,MAAArC,KAAA,EAAAiD,OAAA,aAAA1B,WAAA,CAAA0B,OAAA;MACA,KAAAC,KAAA,UAAAlD,KAAA;MACA,KAAAkD,KAAA,cAAAV,CAAA;IACA;IACAW,QAAA,WAAAA,SAAA;MACA,KAAAtC,QAAA;MACAlB,GAAA,CAAAyD,QAAA,oBAAAb,UAAA;MACA5C,GAAA,CAAAyD,QAAA,kBAAAD,QAAA;MACA,KAAAD,KAAA;IACA;IACAG,eAAA,WAAAA,gBAAAb,CAAA;MACA,KAAAI,UAAA,QAAA3B,YAAA,GAAAuB,CAAA,CAAAE,KAAA,GAAAF,CAAA,CAAAG,KAAA;MACA,KAAA/B,SAAA,QAAAZ,KAAA;MACA,KAAAa,QAAA;MACAnB,EAAA,CAAA0D,QAAA,oBAAAb,UAAA;MACA7C,EAAA,CAAA0D,QAAA,kBAAAD,QAAA;MACA,KAAAD,KAAA;IACA;EACA;EACAI,KAAA;IACAtD,KAAA,WAAAA,MAAA;MACA,KAAAW,MAAA,SAAAQ,SAAA,QAAAM,UAAA,MAAAzB,KAAA,OAAA8B,KAAA,CAAAC,YAAA,MAAAX,UAAA,UAAApB,KAAA;IACA;EACA;EACAuD,OAAA,WAAAA,QAAA;IAAA,IAAAC,KAAA;IACA,KAAAC,SAAA;MACAD,KAAA,CAAA7C,MAAA,IAAA6C,KAAA,CAAArC,SAAA,GAAAqC,KAAA,CAAA/B,UAAA,CAAA+B,KAAA,CAAAxD,KAAA,EAAAwD,KAAA,CAAA1B,KAAA,CAAAC,YAAA,CAAAyB,KAAA,CAAApC,UAAA,KAAAoC,KAAA,CAAAxD,KAAA;IACA;EACA;AACA","ignoreList":[]}]}